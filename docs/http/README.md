# HTTP

  HTTP协议经历以下版本：

  1. HTTP/0.9
  2. HTTP/1.0
  3. HTTP/1.1
  4. HTTP/2
  5. HTTP/3

## HTTP 发展

### HTTP/0.9

  20世纪90年代初提出，没有形成规范，功能有限，动作从服务器上获取 HTML 文档，并且在响应请求之后立即关闭连接。

### HTTP/1.0

  1996年正式发布，但是并未形成标准，不具有约束力。对比HTTP/0.9有以下更新：

  1. 增加了 HEAD、POST 等新方法；
  2. 增加了响应状态码，标记可能的错误原因；
  3. 引入了协议版本号概念；
  4. 引入了 HTTP Header（头部）的概念，让 HTTP 处理请求和响应更加灵活；
  5. 传输的数据不再仅限于文本。

### HTTP/1.1

  1996年，HTTP/1.1发布RFC文档，正式确立了HTTP协议的标准。同时HTTP/1.1是目前使用最为广泛的HTTP协议版本，比起 0.9/1.0 少了“学术气”，更加“接地气”，同时表述也更加严谨。HTTP/1.1 主要的变更点有：

  1. 增加了 PUT、DELETE 等新的方法；
  2. 增加了缓存管理和控制；
  3. 明确了连接管理，允许持久连接；
  4. 允许响应数据分块（chunked），利于传输大文件；
  5. 强制要求 Host 头，让互联网主机托管成为可能。

### HTTP/2

  2015年谷歌制定发布，HTTP/2 的制定充分考虑了现今互联网的现状：宽带、移动、不安全，在高度兼容HTTP/1.1 的同时在性能改善方面做了很大努力，主要的特点有：

  1. 二进制协议，不再是纯文本；
  2. 可发起多个请求，废弃了 1.1 里的管道；
  3. 使用专用算法压缩头部，减少数据传输量；
  4. 允许服务器主动向客户端推送数据；
  5. 增强了安全性，“事实上”要求加密通信。

### HTTP/3

  2018 年，互联网标准化组织 IETF 提议将“HTTP over QUIC”更名为“HTTP/3”并获得批准，HTTP/3 正式进入了标准化制订阶段，也许两三年后就会正式发布，到时候我们很可能会跳过 HTTP/2 直接进入 HTTP/3。

## HTTP概述

  HTTP就是超文本传输协议，也就是HyperText Transfer Protocol.

### 概念拆分

  HTTP概念拆分理解为三部分：**“超文本”，“传输”和“协议”**。

  ![HTTP概念拆分理解](../.vuepress/public/http/http-1.jpg 'HTTP概念拆分理解')

### 协议

  **HTTP 是一个用在计算机世界里的协议。它使用计算机能够理解的语言确立了一种计算机之间交流通信的规范，以及相关的各种控制和错误处理方式。**

### 传输

  **HTTP 是一个在计算机世界里专门用来在两点之间传输数据的约定和规范。**

### 超文本

  它是文字、图片、音频和视频等的混合体，最关键的是含有“超链接”，能够从一个“超文本”跳跃到另一个“超文本”，形成复杂的非线性、网状的结构关系。

### 小结

  1. HTTP 是一个用在计算机世界里的协议，它确立了一种计算机之间交流通信的规范，以及相关的各种控制和错误处理方式
  2. HTTP 专门用来在两点之间传输数据，不能用于广播、寻址或路由。
  3. HTTP 传输的是文字、图片、音频、视频等超文本数据。
  4. HTTP 是构建互联网的重要基础技术，它没有实体，依赖许多其他的技术来实现，但同时许多技术也都依赖于它。

## TCP/IP

### TCP/IP 分成模型

![TCP/IP 分成模型](/http/http-TCPIP.jpg)

  1. 链路层（link layer），负责在以太网、WiFi 这样的底层网络上发送原始数据包，工作在网卡这个层次，使用 MAC 地址来标记网络上的设备，所以有时候也叫 MAC层。
  2. “网际层”或者“网络互连层”（internet layer），IP 协议就处在这一层。因为IP 协议定义了“IP 地址”的概念，所以就可以在“链接层”的基础上，用 IP 地址取代MAC 地址，把许许多多的局域网、广域网连接成一个虚拟的巨大网络，在这个网络里找设备时只要把 IP 地址再“翻译”成 MAC 地址就可以了。
  3. “传输层”（transport layer），这个层次协议的职责是保证数据在 IP 地址标记的两点之间“可靠”地传输。（TCP和UDP传输）
  4. “应用层”（application layer），各种面向具体应用的协议，例如 Telnet、SSH、FTP、SMTP、HTTP 等等.

  MAC 层的传输单位是帧（frame），IP 层的传输单位是包（packet），TCP 层的传输单位是段（segment），HTTP 的传输单位则是消息或报文（message）。但这些名词并没有什么本质的区分，可以统称为数据包。

### TCP/IP 协议栈的工作方式

![TCP/IP 分成模型](/http/http-TCPIP-work.jpg)

  以HTTP协议传输为例：

  1. 当HTTP协议进行资源的传输时，例如HTML文件，HTTP协议会为它加一个HTTP专用数据（应用层）。
  2. 资源向下层传递进过传输层 TCP 为资源加上 TCP头。
  3. 资源进过IP层和MAC层加上IP头，MAC头。
  4. 资源传输到时，依次解开头部信息，得到请求的资源。

### 小结

  1. HTTP 利用 TCP/IP 协议栈逐层打包再拆包，实现了数据传输，但下面的细节并不可见。
  2. 一般情况下，TCP/IP协议的底层又操作系统负责，代码能够影响的是第七层应用层（OSI七层网络模型）

## HTTP 基础知识

### 输入网址回车后发生了什么

  ![输入网址回车](/http/http-2.jpg)
  HTTP 请求过程（未考虑域名解析，浏览器加载）：

  1. 浏览器从地址栏的输入中获得服务器的 IP 地址和端口号；
  2. 浏览器用 TCP 的三次握手与服务器建立连接；
  3. 浏览器向服务器发送拼好的报文；
  4. 服务器收到报文后处理请求，同样拼好报文再发给浏览器；
  5. 浏览器解析报文，渲染输出页面。

  当使用域名访问WEB服务器时，会增加域名查找的IP地址的过程，查找是会在先在多级缓存中查找IP地址（浏览器缓存，系统缓存 host 文件，甚至路由器缓存），缓存中没有时则想域名服务器查找，有根域名服务器 -> 顶级域名服务器 -> 权威域名服务器 （二级域名服务器 -> 三级域名服务器）

  ![输入网址回车](/http/http-dns.jpg)

### CDN 原理

  CDN存储变化不大的资源，一般资源文件存储在CDN上。（动态的后端服务是无法CDN的）

  ![输入网址回车](/http/http-cdn.jpg)

## HTTP 报文结构

  HTTP 协议的请求报文和响应报文的结构基本相同，由三大部分组成：

  1. 起始行（start line）：描述请求或响应的基本信息
  2. 头部字段集合（header）：使用 key-value 形式更详细地说明报文
  3. 消息正文（entity）：实际传输的数据，它不一定是纯文本，可以是图片、视频等二进制数据

### HTTP 请求报文

  ![HTTP 请求报文](/http/http-4.jpg)

### HTTP 响应报文

  ![HTTP 响应报文](/http/http-5.jpg)

### HTTP 头字段规范

  1. 字段名不区分大小写，例如“Host”也可以写成“host”，但首字母大写的可读性更好；
  2. 字段名里不允许出现空格，可以使用连字符“-”，但不能使用下划线“_”。例如，“test-name”是合法的字段名，而“test name”“test_name”是不正确的字段名；
  3. 字段名后面必须紧接着“:”，不能有空格，而“:”后的字段值前可以有多个空格；
  4. 字段的顺序是没有意义的，可以任意排列不影响语义；
  5. 字段原则上不能重复，除非这个字段本身的语义允许，例如 Set-Cookie。
   
## HTTP URI

### HTTP 统一资源标识符

  ![HTTP URI](/http/http-uri.jpg)

## HTTP 的特点

  1. HTTP 是灵活可扩展的，可以任意添加头字段实现任意功能；
  2. HTTP 是可靠传输协议，基于 TCP/IP 协议“尽量”保证数据的送达；
  3. HTTP 是应用层协议，比 FTP、SSH 等更通用功能更多，能够传输任意数据；
  4. HTTP 使用了请求 - 应答模式，客户端主动发起请求，服务器被动回复请求；
  5. HTTP 本质上是无状态的，每个请求都是互相独立、毫无关联的，协议不要求客户端或服务器记录请求相关的信息。
  6. HTTP 是明文传输，数据完全肉眼可见，能够方便地研究分析，但也容易被窃听；
  7. HTTP 是不安全的，无法验证通信双方的身份，也不能判断报文是否被窜改；
  8. HTTP 的性能不算差，但不完全适应现在的互联网，还有很大的提升空间。

## HTTP 连接管理

  在HTTP/1.1之前，HTTP协议在一次请求结束后都会关闭TCP的连接，等下一次的HTTP请求在次建立TCP的连接，导致TCP的握手和挥手浪费了大量的时间。HTTP/1.1之后，TCP建立连接后，后续的HTTP请求将继续使用第一次建立TCP连接，避免重建TCP连接造成的效率低下。

  ![HTTP 连接对比](/http/http-6.jpg)
  
  HTTP的长连接由请求头 Connection: keep-alive 控制，默认是开启的状态，当请求头 Connection: close 长连接关闭。
  服务器与客户端的长连接一般情况下是不会断开的，但是客户端与服务器持续的建立长连接，一定十分的耗费服务器的资源，所以要制定一定的策略关闭长连接，节约服务器的资源，

  1. 请求端和服务器制定请求头 Keep-alive: timeout=Value 限定长连接的时间，但是这个字段约束并不强。
  2. 服务器制定长连接策略，以Nginx为例，配置 keepalive_timeout，如果在一段时间内连接上没有任何数据收发就主动断开连接，配置 keepalive_requests，当 Nginx 在这个连接上处理了设置的请求个数后，也会主动断开连接

## 队头阻塞

  造成对头阻塞的原因与HTTP的长连接和短连接没有关系，而是由 HTTP 基本的“请求 - 应答”模型所导致的。
  当客户端向服务器请求100个数据是，HTTP的响应必须和队列一样，依次响应，当前面的HTTP响应阻塞后续的请求也会阻塞，得不到响应的数据。解决方案：

  1. 并发连接，客户端对服务器建立多个TCP长连接，一般由于各个浏览器的不同，TCP的并发连接的数量控制也不同，以Chrome浏览器为例，并发连接数量有8个。（服务器的资源可能会扛不住或者被认为是恶意攻击，造成无法访问）。
  2. 域名分片，并发连接的数量控制只针对域名，可以客户端连接多个域名，然后与多个域名建立TCP连接，增加并发连接数量，而连接的域名由指向目标域名。（比较少见）
  
## HTTP 重定向

  HTTP的重定向对于用户来说是无感知的（浏览器的使用者），由响应头 Location 控制，该字段为响应字段，必须出现在响应报文里，必须在状态码301/302下才有意义，重定向的地址可以是相对的地址也可以是绝对地址，绝对地址必须是完整的URI。
  301 302状态码的区别：301 是永久重定向，302是临时重定向，301重定向时，流浪器会做一些优化，更新历史记录，书签地址，下次访问时直接使用重定向的地址，省去跳转的成本，搜索引擎的爬虫也会更新索引库。302临时重定向会认为原来的URI地址还是有效的，每次请求时仍会用原来的URI。

## HTTP Cookie

  HTTP 是无状态的协议，Cookie为了保存一定的信息。

### Cookie 工作过程

  当客户端发起请求后，服务端为了让客户端记住一些信息，会在响应头里设置 Se-Cookie 字段，形式为 Key=Value，同时能够设置过期时间，Expires 和 Max-Age（优先级更大），指定 Domain 域名和 Path 路径，客户端下一次发起请求时，会根据 Domain，Path 选择性的把 Set-Cookie 所要发送的填写在请求头Cookie中。

  ![HTTP Cookie](/http/http-cookie.jpg)

  由于Cookie往往包含了用户的敏感数据，为了保证的Cookie的安全性，可以设置HttpOnly，SameSite，Secure 保证Cookie的安全性，以及防止Cookie被滥用。

## HTTP 缓存

  HTTP 缓存策略有服务器控制，响应头中 Cache-Control 告知客户端。通常使用 Max-Age 缓存策略（没有HTTP代理的情况下）
  
  1. max-age是 HTTP 缓存控制最常用的属性，此外在响应报文里还可以用其他的属性来更精确地指示浏览器应该如何使用缓存。（Last-modified 和 ETag，浏览器使用缓存此处不在考虑）
  2. no_store 不允许缓存，用于某些变化非常频繁的数据，例如秒杀页面
  3. must-revalidate：又是一个和 no_cache 相似的词，它的意思是如果缓存不过期就可以继续使用，但过期了如果还想用就必须去服务器验证

  ![HTTP 缓存](/http/http-cache.jpg)
